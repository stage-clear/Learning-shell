# 環境

## 5.1 シェルスクリプトを定義すること

- シェルスクリプトの一番最初には `#!/bin/sh` と書きます
- `#!` はマジックナンバーで、これによりファイルがインタプリタ的に動作するものとして認識される

|指定|シェル|
|:--|:--|
|`#!/bin/sh`|Bシェル (Bourne shell)|
|`#!/bin/csh`|Cシェル|
|`#!/bin/ksh`|Kシェル (Korn shell)|

|ファイルの先頭|動作するシェル|
|:-:|:--|
|`#`|Cシェル上で実行するときはCシェル|
|`:`|Bシェル|


## 5.2 環境変数

- 環境変数とは、プロセスが作られたときに引き継がれる「名前とその値」が組になったもの
- プロセスができるときに親の環境をコピーしてきます
- シェルスクリプトも実行時に親の環境変数を自分のシェル変数としてコピーしてきます
- そのプロセスで値を変更しても、親には影響を与えません
- `set` を引数なしに実行すると、今そこでセットされている変数の名前と値の一覧が得られます
- `env` では今セットされている環境変数の一覧が得られます


### 5.2.1 子の環境を変更する

- 普通に変数の値を設定・変更しても、その変数が環境変数になるわけではありません
- 環境変数を追加・変更するには、`export` を使います


__例) `make` に環境変数を指定して処理する__

```sh
$ CFLAGS=-g
$ export CFLAGS
$ make
```

`export` した変数は、`make` 以外のコマンドやプロセスに影響を与えることになります


__例) ある一部分だけに影響させたい場合__

```sh
$ (CFLAGS=-g; export CFLAGS; make)
$
# あるいは以下のように書くこともできます
$ CFLAGS=-g make    # 同一行のコマンドに有効。セミコロンでコマンドを区切らない
```


### 5.2.2 親の環境を変更する

- 基本的に親の環境を変更することはできません
- 2つのプロセスの間で情報を交換したいなら、なにかファイルを仲立ちさせるのが基本的なやり方です


## 5.2.3 PATH 変数

- PATH 変数にはディレクトリの一覧が入っています
- なにかコマンドを打ったとき、このディレクトリを順番にそのコマンドがあるかないかを調べます
- シェルスクリプトは、PATH変数の値を親プロセスから引き継ぐのが普通です
- コマンドは普通 `/` を含めずその名前だけを指定します
- シェルは名前だけのコマンド指定があったとき、PATH 変数のなかのディレクトリを順に探します
- PATH 変数にならべてある順序も重要です

```sh
$ echo  $PATH
```

自分の書いたシェルスクリプトや、自分の作ったコマンドを普通のコマンドとして使用したいのなら、
PATH変数にそれらが置いてあるディレクトリを追加すればいいだけです。仮にそのディレクトリを
ホームディレクトリ下の `mycmd` というディレクトリだとすれば次のように書けます

```sh
PATH=$PATH:$HOME/mycmd; export PATH
```

- ディレクトリが存在するかしないかや、指定の重複は問題にはならない
- 関数内で追加する場合は注意が必要。実行するたびに追加されていくことになります

__シェルスクリプトの中から、同じディレクトリにある他のシェルスクリプトを実行させる__

```sh
PATH=$PATH:`dirname $0`; export PATH
# $0 はこのプログラムの名前で、dirname はそのコマンドがあるディレクトリのパスを返す
```


## 5.3 ユーザ情報、マシン情報

### 5.3.1 ユーザ名の取得

- `USER` あるいは `LOGNAME` という環境変数があり、現行のユーザの名前がセットされています
- ユーザの名前をしるには、`whoami` `logname` `id` `who` といったコマンドが使えます

__例)__

```sh
$ whoami
user
$ logname
user
$ id
uid=1001(user) gid=1001(usergrp)
$ who
user      console  Nov 26 11:08
user      ttys000  Nov 26 15:55
```

__例) `id` コマンドからユーザ名を得る__

```sh
$ USER=`id | sed 's/uid=.*(\(.*\)) gid=.*/\1/'`
$ UID=`id | sed -e 's/uid=//' -e 's/(.*//'`
```

__例) `who` からユーザ名を得る__

```sh
$ USER=`who am i | awk '{print $1}'`
$ USER=`who am i | sed -e 's/ .*//' -e 's/.*!//'`
```

__例) id が 0 かどうかを判定する__

```sh
if id | grep "^uid=0(" > /dev/null 2>&1
then
  echo "Is superuser"
else
  echo "Is not superuser"
fi
```

関数とする場合

```sh
IsSuperuser() {
  case `id` in
    "uid=-("* ) return 0 ;;
    * )         return 1 ;;
  esac
}
```


### 5.3.2 マシン名称の取得

- `hostname` で、そのマシンの名称をとってくることができます
- このコマンドがない場合は `uname` を使います
- ホストの名前だけを返す場合とドメイン名をつけて返す場合があります


```sh
$ HOSTNAME=`hostname`
$ HOSTNAME=`hostname | sed -e 's/\..*//'`
```


## 5.4 シグナルの処理

- 普通、プロセスはシグナルを受け取ると実行を中断します
- やたら途中で中断されても困るため、シェルではシグナルを受け取ったときにいろいろな処理をさせる
ことが可能になっています。`trap` コマンドを使います
- `trap` コマンドはどこに書いてもかまわないですが、通常はできるだけ始めの方に書きます


```sh
$ trap commadn-list signal_number
```

`signal_number` に指定した番号のシグナルを受け取ったとき、`command-list` のコマンドを実行します

```sh
$ trap command-list signal_number   # シグナルを受け取って処理する
$ '' signal_number                  # シグナルを無視する
$ signal_number                     # シグナルをリセットする
```

__例)__

```sh
$ sleep 1200 &
$ ps | grep sleep
3839 ttys000    0:00.00 sleep 1200
3841 ttys000    0:00.00 grep sleep
$
$ kill -1 3839
[1]+  Hangup: 1               sleep 1200
$
```

|番号|シグナルの説明|
|:-:|:--|
|`0`|実際のシグナルではない。`trap` に0番を指定するとそのシェル自身の終了処理を行わせられる|
|`1`|ハングアップシグナル `SIGHUP`: 切断したりクローズしたり|
|`2`|割り込みシグナル `SIGINT`: キーボードからの割り込み信号。`Ctrl-C` や `Delete` キー|
|`3`|クィットシグナル `SIGQUIT`: キーボードからのクィット信号。`CTRL-\`|
|`9`|キルシグナル `SIGKILL`: プロセスを強制終了します。|
|`15`|終了シグナル `SIGTERM`: アプリケーションを終了するときに用いるシグナル。`kill` のデフォルト|


### 5.4.1 シグナルのキャッチ
