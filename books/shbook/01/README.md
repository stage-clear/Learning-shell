# 書き方にかかわる基本的な説明

## 1.1 シェルスクリプトを作る際の基本事項

`#!` に続くコマンドが宣言となる。

```sh
#!/bin/sh
```

- [サンプル) あるファイルを別のファイルとくっつける](append)

```sh
$ append abc xyz
-bash: append: command not found

$ ./append abc xyz
-bash: ./append: Permission denied

$ ls -l
-rw-r--r--  1 nepdigital  staff  117 11  2 11:49 append
```

`append` ファイルのモードが `-rw-r--r--` となっているところに注意する
これは「作った本人は読み書きができ、他の人はみることだけができるファイル」という意味で、
「実行する許可がない」というエラーです。
シェルスクリプトはコマンドと同じように「実行できる」ようにしておかなくてはなりません。

```sh
$ chmod +x append
$ ls -l append
-rwxr-xr-x  1 nepdigital  staff  117 11  2 11:49 append
```

再度、実行します。

```sh
$ append abc xyz
$
# なにもいわずプロンプトが返る

$ ls -l
-rw-r--r--  1 nepdigital  staff     4 11  2 11:44 abc
-rwxr-xr-x  1 nepdigital  staff   117 11  2 11:49 append
-rw-r--r--  1 nepdigital  staff     8 11  2 11:58 xyz
```

`xyz` のファイルの大きさが増え、`abc` ファイルの文字数を加えたものになっている。

```sh
$ append FROMFILE TOFILE
```

とタイプすればいいということになります。

### まとめると

- シェルプログラムの先頭には、`#!/bin/sh` を書く
- シェルプログラムには、実行権限 （`x` フラグ）を与える


> `append: not found` というエラーになった場合は、コマンドのサーチパス（PATH変数）がセ
ットされていません。その場合は、 `$ ./append abc xyz` と実行してください。


## 1.2 コメントを書く場合

- `#` : 行コメント
- `#` : どの位置にあってもよく、`#` から行末までがコメント扱いとなる

```sh
#!/bin/sh
#
# この # で始まっている 5 行はすべてコメントです
# ここにはなにを書いてもかまいませんが、
# 少なからず意味のあることにしましょう
#
echo 'Hello World.' # ここもコメント
```


## 1.3 1行の取り扱い

- UNIX のコマンドは、どんなものでも「改行」で完結します
- `enter` キーを打つことでそのコマンドを実行させるということになります
- 1つのコマンドは1行に書いてしまわなくてはならない

```sh
$ echo Hello \
> World.
Hello World.
$
```

- `\` の直後の改行は無視される
- `\` の直前にスペースをいくら置いても1つのスペースで置き換えられる
- 故意に複数のスペースを置きたい場合は `"` などを使って指定する

```sh
$ echo "Hello       \
World."
```

## 1.4 ファイル名称の補完

- 「ワイルドカード」という、ファイル名称を補完する機能がある

> UNIX で「ファイル」というとき、どんなものでも形してそこにあるものはすべて「ファイル」で
す。普通のテキストファイルはもとより、ディレクトリやコマンドやデバイスすらも、ファイル
として取り扱います。

__ファイル指定するときに使えるワイルドカード__

|WildCard|Summary|
|:--|:--|
|`*`|文字列全部（文字がなくても）|
|`?`|1文字|
|`[...]`|`[ ]` の中に含まれる文字のどれか1つ|
|`[!...]`|`[ ]` に含まれない文字|

`[...]` というのは、`[a8mc]` というふうに文字を個別に指定することもできますし、
`[a-h3-9D-L]` というように `-` で範囲指定させてもかまいません


__ワイルドカードによるファイル指定の例__

|WildCard|Summary|
|:--|:--|
|`*tmp`|~tmp というように、tmp で終わるファイル。ただの tmp も含む|
|`*tmp*`|ファイル名の中に tmp という文字列が入っているもの|
|`[a-z]*`|a から z までの文字のどれかで始まるファイル|
|`[-a-z]*`|ハイフンか、a から z までの文字のどれかで始まるファイル|
|`[a-zA-Z]*`|アルファベットの小文字か大文字で始まるファイル|
|`*[0-9]*`|ファイル名の中に数字が含まれているもの|
|`[!0-9]*`|数字で始まらないファイル|
|`??`|名前が2文字のファイル|
|`??*`|名前が2文字以上のファイル|
|`tmp/*`|tmp というディレクトリ下の全ファイル|

- `[a-zA-Z]` をアルファベット全部ということで `[a-Z]` と書くと間違いです。`[ ]` の中
の `-` （ハイフン）は「文字コード」の大小で範囲を判断します。


### 1.4.1 隠しファイル

- `.` （ドット）で始まるファイルを「隠しファイル」と呼びます。`ls` コマンドを叩いたと
きに、通常は表示されないためそう呼ぶようになりました
- ワイルドカードを使ったときも、`.` で始まるファイルだけは例外です。最初の文字が `.`で
あると明示的に指定しなくてはならないのです


__. ファイルの観点に着目したワイルドカードの指定の例__

|WildCard|Summary|
|:--|:--|
|`*`|その名前の先頭が `.` ではないすべてのファイル|
|`.*`|名前の先頭が `.` のファイル。`.` や `..` というものも含まれる|
|`.?`|`.` で始まる2文字の名称のファイル。`.d` など|
|`?`|`.` ではない任意の1文字のファイル|
|`[.a]*`|a で始まるファイル。`.` で始まるファイルは含まれない|
|`direcory/*`|そのディレクトリ下の全ファイル。ただし `.` で始まるものは含まない|
|`directory/.*`|`.` や `..` も含めて、名前が `.` で始まるファイル|

> `[.a]*` と書いたときに、`.` で始まるファイルが含まれないのはちょっと解せないかもし
れません。シェルは、`[ ]` で指定された文字がファイル名の中にあるかどうかを判断するとき
に、すでに `.` で始まるファイルを除外しているのです。`.` で始まるファイルを指定したい
場合は、明示的に `.` で始まるものと指示しなければいけません


## 1.5 クオテーションの使い方

- ワイルドカードや、シェルにとって特殊な意味を持つ文字（メタキャラクタや特殊文字と言う）、
スペースや変数というものは、コマンドが実行される前にシェルによって解釈され展開されます。

場合によっては、これを勝手にしてもらいたくない場合もあります。
例えばファイル名称に空白文字を使っている `abc xyz` というファイルがあるとき、`ls -l abc xyz`
とやっても `ls` コマンドは `abc` と `xyz` という2つのファイルだと解釈してしまい、目的
のファイルを見ることはできません。

クォーテーションには3つの方法があります

- バックスラッシュ `\` を使う
- シングルクォート `'` を使う
- ダブルクォート `"` を使う

以下の文字を「普通の文字」として使うときに、クォーテーションによる「囲み」が必要になる

```
; & ( ) | ^ < > ? * [ ] $ ' " ` { } 改行 タブ スペース
```

### 1.5.1 バックスラッシュ `\`

- 1文字をクォートするには、`\` を使うのが便利です
- この直後の文字の特殊な意味をなくす機能から、`\` をエスケープキャラクタとも呼びます
- クォートする対象が1文字であるというほかは、`'` とほぼ同等の機能です

```sh
$ exho abc\\def
abc\def
```

> 「`\` （改行）」は改行のクォートとは違います。`\$` は `$` を取り出せますが、`\ 改行`
では改行コードは取り出せません。改行コードの直前に `\` を置いたとき、 `\` 直後の改行
コードを「ないもの」として扱います。


### 1.5.2 シングルクォーテーション `'`

- これがシェルのクォーテーションの中では一番協力なものです
- `'` に囲まれた文字列（`'.....'`）の中の特殊文字は、すべて普通の文字と同じ扱いとなる
- `'` でエスケープできないのはシングルクォート `'` だけです


### 1.5.3 ダブルクォーテーション

- `"` はほとんどの特殊文字の意味をエスケープし、文字そのものとして扱います
- ただし、`$` `バッククオート` `\` という3つの特殊文字は、`"` で囲んでもエスケープできません
- これら3つの文字をエスケープさせたいときは、`'` を使わなければならない
- `"` 内の `\` の直後にこれら3つの文字がある場合に限って、ちゃんとエスケープされる


__`Foo`　という変数に、`foo` という文字列を代入した例__

```sh
$ FOO=foo       # FOO という変数に文字列 foo を代入する

$ echo $FOO     # 普通に表示させると
foo             # 変数に代入された文字列に置き換わって表示される

$ echo "$FOO"   # ダブルクォートで囲む
foo             # $の意味はそのままで囲まない場合と同じ結果となる

$ echo "\$FOO"  # ダブルクォートの中の $ を \ でエスケープ
$FOO            # $ の意味が剥ぎ取られて、そのまま表示される

$ echo "F\OO"   # ダブルクォート内の \ が普通の文字の前にある場合
F\OO            # \ の機能は剥ぎ取られて、そのまま表示される

$ echo '$FOO'   # シングルクォートで囲む
$FOO            # 囲まれた中の文字列がそのまま表示される

$ echo '\$FOO'  # シングルクォートの中の $ を \ でエスケープ
\$FOO           # シングルクォートは全部をエスケープするからそのまま表示される
```


### 1.5.4 どんなときにクォートを使うのか

- 何かコマンドを実行させるとき、渡す引数をシェルが自動的に解釈しないようにしたい場合
- 例えば引数にスペースが入っていたり何か特殊文字がある場合

__「空白文字」の例__

`test` というコマンドを使います。このコマンドは3つの引数が必要で、3つの引数はそれぞれ
「空白文字」で区切られ、真ん中の引数はイコール記号 `=` です。

```sh
$ test string1 = string2
```

`string1` と `string2` はそれぞれの任意の文字列です。

```sh
$ test john = john
$ test "john" = "john"
# この2つはどちらも正しい書き方です
```

`=` の左側に「空白文字」が含まれていた場合

```sh
$ test John Doe = john
# 4つの引数が与えられたように解釈され、このコマンドはエラーとなります

# ダブルクォートで囲みます
$ test "John Doe" = john
$ test "John Doe" = "john"
# この2つはどちらも正しい書き方です
```

似たような問題として、「空っぽの文字列」を指定する場合があります

```sh
# 左側の文字列にはなにもないので、そのまま書くと
$ test  = john
# ということになります
# しかし、これでは引数が2つになってしまうので正しくありません

# 何もない」状態をちゃんと指定しているという意味で次のように書きます
$ test "" = "john"
# これは正しい書き方です
# これは実際に変数を使ったときに非常によくみられる現象です
```

```sh
$ STRING=
$ test $STRING = john
# これだと`STRING` という変数には何も入っていません
# 変数の値を置き換えると
$ test  = john
# とかいたことと同じになります。

# 正しくするためには
$ STRING=
$ test "STRING" = "john"
# というように書かなくてはなりません
```

この例は、クォートを使うか使わないかの違いを見るためのもので、それならいつも使うように
すればいい、とは考えないでください。大抵の場合は使ってもいいのですが、使ってはならない
場合もやはり多々あるのです。
大事なことは、シェルがそれを解釈してもいいかどうかということです。

もう1つ、次の例を考えてみます。

```sh
$ echo *
```

これは `*`（アスタリスク）を表示させようとしているのでしょうか、それとも、`ls` コマンド
と同じことをやらせようとしているのでしょうか
普通にこのようにすると、`ls` コマンドと同じ結果が得られます。もしそうでなく、ただ `*`
を出力させたいときには、クォーティングして、

```sh
$ echo "*"
```

と書かなくてはなりません。


### 1.5.5 クォーテーションの使い分け
