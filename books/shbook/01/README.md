# 書き方にかかわる基本的な説明

## 1.1 シェルスクリプトを作る際の基本事項

`#!` に続くコマンドが宣言となる。

```sh
#!/bin/sh
```

- [サンプル) あるファイルを別のファイルとくっつける](append)

```sh
$ append abc xyz
-bash: append: command not found

$ ./append abc xyz
-bash: ./append: Permission denied

$ ls -l
-rw-r--r--  1 nepdigital  staff  117 11  2 11:49 append
```

`append` ファイルのモードが `-rw-r--r--` となっているところに注意する
これは「作った本人は読み書きができ、他の人はみることだけができるファイル」という意味で、
「実行する許可がない」というエラーです。
シェルスクリプトはコマンドと同じように「実行できる」ようにしておかなくてはなりません。

```sh
$ chmod +x append
$ ls -l append
-rwxr-xr-x  1 nepdigital  staff  117 11  2 11:49 append
```

再度、実行します。

```sh
$ append abc xyz
$
# なにもいわずプロンプトが返る

$ ls -l
-rw-r--r--  1 nepdigital  staff     4 11  2 11:44 abc
-rwxr-xr-x  1 nepdigital  staff   117 11  2 11:49 append
-rw-r--r--  1 nepdigital  staff     8 11  2 11:58 xyz
```

`xyz` のファイルの大きさが増え、`abc` ファイルの文字数を加えたものになっている。

```sh
$ append FROMFILE TOFILE
```

とタイプすればいいということになります。

### まとめると

- シェルプログラムの先頭には、`#!/bin/sh` を書く
- シェルプログラムには、実行権限 （`x` フラグ）を与える


> `append: not found` というエラーになった場合は、コマンドのサーチパス（PATH変数）がセ
ットされていません。その場合は、 `$ ./append abc xyz` と実行してください。


## 1.2 コメントを書く場合

- `#` : 行コメント
- `#` : どの位置にあってもよく、`#` から行末までがコメント扱いとなる

```sh
#!/bin/sh
#
# この # で始まっている 5 行はすべてコメントです
# ここにはなにを書いてもかまいませんが、
# 少なからず意味のあることにしましょう
#
echo 'Hello World.' # ここもコメント
```


## 1.3 1行の取り扱い

- UNIX のコマンドは、どんなものでも「改行」で完結します
- `enter` キーを打つことでそのコマンドを実行させるということになります
- 1つのコマンドは1行に書いてしまわなくてはならない

```sh
$ echo Hello \
> World.
Hello World.
$
```

- `\` の直後の改行は無視される
- `\` の直前にスペースをいくら置いても1つのスペースで置き換えられる
- 故意に複数のスペースを置きたい場合は `"` などを使って指定する

```sh
$ echo "Hello       \
World."
```

## 1.4 ファイル名称の補完

- 「ワイルドカード」という、ファイル名称を補完する機能がある

> UNIX で「ファイル」というとき、どんなものでも形してそこにあるものはすべて「ファイル」で
す。普通のテキストファイルはもとより、ディレクトリやコマンドやデバイスすらも、ファイル
として取り扱います。

__ファイル指定するときに使えるワイルドカード__

|WildCard|Summary|
|:--|:--|
|`*`|文字列全部（文字がなくても）|
|`?`|1文字|
|`[...]`|`[ ]` の中に含まれる文字のどれか1つ|
|`[!...]`|`[ ]` に含まれない文字|

`[...]` というのは、`[a8mc]` というふうに文字を個別に指定することもできますし、
`[a-h3-9D-L]` というように `-` で範囲指定させてもかまいません


__ワイルドカードによるファイル指定の例__

|WildCard|Summary|
|:--|:--|
|`*tmp`|~tmp というように、tmp で終わるファイル。ただの tmp も含む|
|`*tmp*`|ファイル名の中に tmp という文字列が入っているもの|
|`[a-z]*`|a から z までの文字のどれかで始まるファイル|
|`[-a-z]*`|ハイフンか、a から z までの文字のどれかで始まるファイル|
|`[a-zA-Z]*`|アルファベットの小文字か大文字で始まるファイル|
|`*[0-9]*`|ファイル名の中に数字が含まれているもの|
|`[!0-9]*`|数字で始まらないファイル|
|`??`|名前が2文字のファイル|
|`??*`|名前が2文字以上のファイル|
|`tmp/*`|tmp というディレクトリ下の全ファイル|

- `[a-zA-Z]` をアルファベット全部ということで `[a-Z]` と書くと間違いです。`[ ]` の中
の `-` （ハイフン）は「文字コード」の大小で範囲を判断します。


### 1.4.1 隠しファイル

- `.` （ドット）で始まるファイルを「隠しファイル」と呼びます。`ls` コマンドを叩いたと
きに、通常は表示されないためそう呼ぶようになりました
- ワイルドカードを使ったときも、`.` で始まるファイルだけは例外です。最初の文字が `.`で
あると明示的に指定しなくてはならないのです


__. ファイルの観点に着目したワイルドカードの指定の例__

|WildCard|Summary|
|:--|:--|
|`*`|その名前の先頭が `.` ではないすべてのファイル|
|`.*`|名前の先頭が `.` のファイル。`.` や `..` というものも含まれる|
|`.?`|`.` で始まる2文字の名称のファイル。`.d` など|
|`?`|`.` ではない任意の1文字のファイル|
|`[.a]*`|a で始まるファイル。`.` で始まるファイルは含まれない|
|`direcory/*`|そのディレクトリ下の全ファイル。ただし `.` で始まるものは含まない|
|`directory/.*`|`.` や `..` も含めて、名前が `.` で始まるファイル|

> `[.a]*` と書いたときに、`.` で始まるファイルが含まれないのはちょっと解せないかもし
れません。シェルは、`[ ]` で指定された文字がファイル名の中にあるかどうかを判断するとき
に、すでに `.` で始まるファイルを除外しているのです。`.` で始まるファイルを指定したい
場合は、明示的に `.` で始まるものと指示しなければいけません


## 1.5 クオテーションの使い方

- ワイルドカードや、シェルにとって特殊な意味を持つ文字（メタキャラクタや特殊文字と言う）、
スペースや変数というものは、コマンドが実行される前にシェルによって解釈され展開されます。

場合によっては、これを勝手にしてもらいたくない場合もあります。
例えばファイル名称に空白文字を使っている `abc xyz` というファイルがあるとき、`ls -l abc xyz`
とやっても `ls` コマンドは `abc` と `xyz` という2つのファイルだと解釈してしまい、目的
のファイルを見ることはできません。

クォーテーションには3つの方法があります

- バックスラッシュ `\` を使う
- シングルクォート `'` を使う
- ダブルクォート `"` を使う

以下の文字を「普通の文字」として使うときに、クォーテーションによる「囲み」が必要になる

```
; & ( ) | ^ < > ? * [ ] $ ' " ` { } 改行 タブ スペース
```

### 1.5.1 バックスラッシュ `\`

- 1文字をクォートするには、`\` を使うのが便利です
- この直後の文字の特殊な意味をなくす機能から、`\` をエスケープキャラクタとも呼びます
- クォートする対象が1文字であるというほかは、`'` とほぼ同等の機能です

```sh
$ exho abc\\def
abc\def
```

> 「`\` （改行）」は改行のクォートとは違います。`\$` は `$` を取り出せますが、`\ 改行`
では改行コードは取り出せません。改行コードの直前に `\` を置いたとき、 `\` 直後の改行
コードを「ないもの」として扱います。


### 1.5.2 シングルクォーテーション `'`

- これがシェルのクォーテーションの中では一番協力なものです
- `'` に囲まれた文字列（`'.....'`）の中の特殊文字は、すべて普通の文字と同じ扱いとなる
- `'` でエスケープできないのはシングルクォート `'` だけです


### 1.5.3 ダブルクォーテーション

- `"` はほとんどの特殊文字の意味をエスケープし、文字そのものとして扱います
- ただし、`$` `バッククオート` `\` という3つの特殊文字は、`"` で囲んでもエスケープできません
- これら3つの文字をエスケープさせたいときは、`'` を使わなければならない
- `"` 内の `\` の直後にこれら3つの文字がある場合に限って、ちゃんとエスケープされる


__`Foo`　という変数に、`foo` という文字列を代入した例__

```sh
$ FOO=foo       # FOO という変数に文字列 foo を代入する

$ echo $FOO     # 普通に表示させると
foo             # 変数に代入された文字列に置き換わって表示される

$ echo "$FOO"   # ダブルクォートで囲む
foo             # $の意味はそのままで囲まない場合と同じ結果となる

$ echo "\$FOO"  # ダブルクォートの中の $ を \ でエスケープ
$FOO            # $ の意味が剥ぎ取られて、そのまま表示される

$ echo "F\OO"   # ダブルクォート内の \ が普通の文字の前にある場合
F\OO            # \ の機能は剥ぎ取られて、そのまま表示される

$ echo '$FOO'   # シングルクォートで囲む
$FOO            # 囲まれた中の文字列がそのまま表示される

$ echo '\$FOO'  # シングルクォートの中の $ を \ でエスケープ
\$FOO           # シングルクォートは全部をエスケープするからそのまま表示される
```


### 1.5.4 どんなときにクォートを使うのか

- 何かコマンドを実行させるとき、渡す引数をシェルが自動的に解釈しないようにしたい場合
- 例えば引数にスペースが入っていたり何か特殊文字がある場合

__「空白文字」の例__

`test` というコマンドを使います。このコマンドは3つの引数が必要で、3つの引数はそれぞれ
「空白文字」で区切られ、真ん中の引数はイコール記号 `=` です。

```sh
$ test string1 = string2
```

`string1` と `string2` はそれぞれの任意の文字列です。

```sh
$ test john = john
$ test "john" = "john"
# この2つはどちらも正しい書き方です
```

`=` の左側に「空白文字」が含まれていた場合

```sh
$ test John Doe = john
# 4つの引数が与えられたように解釈され、このコマンドはエラーとなります

# ダブルクォートで囲みます
$ test "John Doe" = john
$ test "John Doe" = "john"
# この2つはどちらも正しい書き方です
```

似たような問題として、「空っぽの文字列」を指定する場合があります

```sh
# 左側の文字列にはなにもないので、そのまま書くと
$ test  = john
# ということになります
# しかし、これでは引数が2つになってしまうので正しくありません

# 何もない」状態をちゃんと指定しているという意味で次のように書きます
$ test "" = "john"
# これは正しい書き方です
# これは実際に変数を使ったときに非常によくみられる現象です
```

```sh
$ STRING=
$ test $STRING = john
# これだと`STRING` という変数には何も入っていません
# 変数の値を置き換えると
$ test  = john
# とかいたことと同じになります。

# 正しくするためには
$ STRING=
$ test "STRING" = "john"
# というように書かなくてはなりません
```

この例は、クォートを使うか使わないかの違いを見るためのもので、それならいつも使うように
すればいい、とは考えないでください。大抵の場合は使ってもいいのですが、使ってはならない
場合もやはり多々あるのです。
大事なことは、シェルがそれを解釈してもいいかどうかということです。

もう1つ、次の例を考えてみます。

```sh
$ echo *
```

これは `*`（アスタリスク）を表示させようとしているのでしょうか、それとも、`ls` コマン
ドと同じことをやらせようとしているのでしょうか
普通にこのようにすると、`ls` コマンドと同じ結果が得られます。もしそうでなく、ただ `*`
を出力させたいときには、クォーティングして、

```sh
$ echo "*"
```

と書かなくてはなりません。


### 1.5.5 クォーテーションの使い分け

ダブルクォートとシングルクォートはどのように使い分けるのでしょう

- __囲んだ文字列の中で、変数の置き換えやコマンド痴漢した結果を使いたい__ ときはダブル
クォートを使用します
- シングルクォートは、シェルによる解釈をまったくさせないもの
- バックスラッシュはあまり頻繁に使わなくてもいい
- 普通ダブルクォートを使っておいて、どうしてもその中の1文字をエスケープしたい状態が出
たときに、バックスラッシュを利用します

```sh
# ファイル名称として変数に代入されている値に置き換えて表示
$ FILE=foobar
$ echo "Cannot remove $FILE"
Cannot remove foobar
$

# `date` コマンドの結果を表示
$ echo "TOday is `data`"
Today is 2015年 11月 2日 月曜日 15時06分36秒 JST
$
```

この場合にシングルクォートを使っていると、次のような結果になり、これは期待したものとは
（普通）違います。

```sh
Cannot remove $FILE
Today is `date`
```

普通シングルクォートを多用するのは、`sed` や `awk` コマンドを使うときではないでしょう
か。これらのコマンドでは、そのまま文字として渡さないといけない状況が頻発します。

__それぞれクォーテーションをエスケープする__

```sh
# ダブルクォートをエスケープするには、シングルクォートを利用する
$ echo `"abc"`
"abc"
$

# シングルクォートをエスケープするには、ダブルクォートを利用する
$ echo "'abc'"
'abc'
$

# バックスラッシュをエスケープするには、シングルクォートでもバックスラッシュでも
$ echo '\'
\
$

$ echo \\
\
$
```

__クォートされているものとそうでないものが混在する状況__

- シングルクォートとダブルクォートは、並列的に混在させることができます
- シングルクォートとダブルクォートは、ネストさせることはできません
- コマンド行は、その行を左から右の順に1つずつ文字をスキャンして判断する


```sh
$ echo 'Part1'Part2"Part3"
Part1Part2Part3

$ echo 'Part1Part2"Part3"'
Part1Part2"Part3"

# シングルクォートの中で変数を展開したい場合
$ echo 'Part1'"$VARIABLE"'part3'
Part1part3
# この方法は、awk コマンドではよく使われるテクニックの1つです
$ who | awk '/^'"$USER"'/ {print $2}'
console
ttys000
```


## 1.6 バッククォートによるコマンド置換

- バッククォートは、その中に書かれたコマンドを実行し、その結果をその位置に書き込みます
- 見た目は似ていますが、シングルクォートと混同しないようする。機能はまったく違います
- バッククォートはよく「逆アポ」と称されます

```sh
$ echo "Today is `date`"
Today is 2015年 11月 2日 月曜日 15時43分42秒 JST
# この例では、バッククォートで囲んだコマンド（date）が実行されて
# その位置に実行結果が書き込まれています

# さらにバッククォートをバックスラッシュでエスケープすることで
# コマンド置換のネストも可能
$ STRING=`echo "abc \`echo def\` ghi"`
# 最初に `echo def` が展開され、`def` に置き換わり、次に echo abc def ghi
# が処理され `STRING` という変数に入ります
```

## 1.7 コマンド終了時のステータス

シェルスクリプトでは、直前のコマンドが正しく終了したかそうでないかを判断し、次に進むス
テップを決めるという書き方をよく行います

- `0　　` : 成功 `true`
- `0以外` : 失敗 `false`
- これをエグジットステータス（終了ステータス、終了コード）という

```sh
if test -f FILE
then
  echo "FILE exists"
fi
# これはいわゆる if 文というものです
# file というファイルが存在していたら test コマンドは 0 を返し、存在しなかったら
# 0 以外の値を返します。0 が返ってきた場合には then から fi までのコマンドを実行する
```

> 他の言語とくらべてしまうとちょっと混乱するかもしれません。例えば、C言語では、リターン
値が0ということは失敗（false）を意味し、他の任意の値が成功（true）を意味します。その点
、勘違いしないようにしてください。

普通この終了コードは、`if` `elif` `while` `||` `&&` といった状態判定文で使われます。
またこの値は `$?` という変数に自動的に代入されます。よって実際にその値を調べたいときは
、あるコマンドを実行した直後に `echo $?` とタイプすればわかります


## 1.8 コマンドセパレータ

コマンドは普通、行の終わり（改行コード）で完結し、1つのコマンド行となります。
その他にも、以下のようにして、コマンドの区切りとすることができます。これらをまとめて、
コマンドセパレータといいます。

|Separator|Summary|
|:--|:--|
|改行|1つのコマンドの区切り|
|`;`|1つのコマンドの区切り|
|`|`|出力された結果を次のコマンドの入力にする|
|`&`|バックグラウンドで実行させる|
|`||`|OR 制御演算子|
|`&&`|AND 制御演算子|


### 1.8.1 セミコロン `;`

- セミコロンで区切られたコマンドは、左から順に実行されます
- 左側のコマンドが終了しないと右のコマンドへ進むことはありません
- セミコロンを使う利点は、複数行にまたがる記述を1行にまとめられることです

```sh
$ cat file1; cat file2; cat file3
# この場合、file1 を表示し、それが終わって file2 を表示、最後に file3 を表示します
```

```sh
# 下記2つはまったく同じ動作をします
$ cd /tmp; ls

$ cd /tmp
$ ls
```


### 1.8.2 パイプ `|`

- これを使った処理は左から右に流していく意味でパイプライン処理と言います
- そこから、この縦棒を「パイプ」と表現するのが普通です
- これは `|` の左側で実行したコマンドの結果を、`|` の右側のコマンドの入力として処理する

__パイプライン処理の例__

```sh
# echo 結果を wc に渡す
$ echo abc | wc

# cat コマンドで file1 と file2 を連続して表示
$ cat file1 file2 | sort | more
```
