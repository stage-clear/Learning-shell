# シェル関数、組み込みコマンド

## 3.1 シェル関数

__基本構文__

```sh
name()
{
  command
  # ....
}

# 以下のように1行で書くこともできます
name() { command-list; }
# `{` の後にスペースを入れておかなくてはならない
# 関数内の最後のコマンドのあとに `;` を打っておかなくてはならない
```

__例) lsl という関数を作り、 `ls -l` と同じことをさせる__

```sh
$ lsl(){      # lsl という名前の関数を作る
> ls -l       # 内容は ls -l コマンド
> }           # これで終わり
$
$ lsl         # 実行テスト
total 48
-rw-r--r--  1 nepdigital  staff  9717 11  9 14:49 README.md
-rwxr-xr-x  1 nepdigital  staff    26 11  9 14:21 kkk
-rwxr-xr-x  1 nepdigital  staff    18 11  9 14:14 mmm
-rwxr-xr-x  1 nepdigital  staff    53 11  9 14:10 nnn
```

- 関数ではその関数の戻り値を自分で設定できます
- `return` コマンドを任意の位置に書き、そこで戻り値を設定します
- 戻り値は実行終了ステータスと同じ扱いとなり、シェル変数の `$?` で参照可能です

```sh
return [n]
```

### 3.1.1 動作状態似寄る違いに関する注意

- 定義した関数は、通常そのカレントシェルで動作し、別のサブシェルを作りません
- ただし、関数内で標準入出力をリダイレクトするような場合、サブシェルを作って動作します

```sh
$ lsl             # カレントシェルで実行され
$ ls -l           # <- を実行したときとまったく同じになります

# 一方、次のように結果をファイルに書き出した場合、サブシェルを作りそこで動作します
$ lsl > ls_file   # 結果を端末でなくファイルに書き出す
```


### 3.1.2 引数（位置パラメタ）に関する注意

- 関数が実行される際、引数は位置パラメタとしてそのまま引き継がれます
- UNIX では位置パラメタはただ一組しか用意されません


```sh
$ lsl(){
> ls -l $*          # <- `$*` で引数をもらうようにする
> }
$
$ lsl               # 引数なし
-rw-r--r--  1 nepdigital  staff  1958 11  9 15:41 README.md
-rw-r--r--  1 nepdigital  staff   286 11  9 15:36 test
$ lsl *.md          # 引数あり
-rw-r--r--  1 nepdigital  staff  1958 11  9 15:41 README.md
```


__例) 受け取った引数を表示する__

```sh
$ posdisplay(){
> echo $0 $2 $3 $4
> }
$
$ posdisplay aaa bbb ccc ddd
-bash bbb ccc ddd
$
```

__例) 引数として渡されたパラメタを変数に保存する__

```sh
#!/bin/sh
POS_PARAM="$@"      # POS_PARAM 変数に引数のリストを代入しておく

some_function(){    # なにか関数の中で
  set               # set コマンドで位置パラメタを設定し直したり
  shift             # shift コマンドでずらしたりすると、
}

some_function       # 関数を利用したあとでは位置パラメタもずれてしまう
set "$POS_PARAM"    # よって代入していた変数の値に戻して再利用する
```


### 3.1.3 変数を使う際の注意

- シェルスクリプトを1個作ると、それで利用する変数を収めるテーブルが1個用意されます
- 関数の中でだけ利用する変数を使いたい場合は、他の関数やそれを呼んだシェルスクリプトで
決して使わないような特殊な名前を使うようにするべきです
- 関数内で仕様する変数名は `_` で始まるようにする。など
- 再帰的に関数を呼ぶ場合、同じ変数をずっと使うことになるので注意する


### 2.1.4 関数をカレントシェルで利用すること

- シェルスクリプトに含まれるコマンドは、そのシェルスクリプト内で動作し、シェルスクリプ
トを起動したシェル上で動くわけではありません
- `.` を使えば、シェルスクリプトをカレントシェルで実行させることも可能です

```sh
$ . script_file
```

関数も同じ

```sh
#!/bin/sh
pse(){
  ps -ax | sort -bn
}
```

```sh
$ ./aaa
$ pse
-bash: pse: command not found
$
$ . ./aaa
$ pse
PID TTY           TIME CMD
  1 ??         1:02.79 /sbin/launchd
 38 ??         0:04.02 /usr/sbin/syslogd
```

- 関数を書き並べたシェルスクリプトを作っておき、ドットコマンドで有効にして自分の普段の
動作環境を使いやすくすることができます。
- 何らかの処理を実行するシェルスクリプトと、このような環境設定をするシェルスクリプトは
異なる目的で作られます
- ドットコマンドを使って実行するファイルには `.sh` を付け明示しておくことが多い
- さらに直接実行しないように、モードは読み書きだけを許可し、ディレクトリも普通のコマン
ドとは分けておくようにします


## 3.2 組み込みコマンド

### 3.2.1 ヌルコマンド `:`

```sh
:
```

- 何もしないがいつも成功する（真を返す）コマンドです
- いつも真の値を返すので、条件判定を必ず真にしたい場合によく使われます

```sh
while :
do
  if #.....
  then
    break         # exit や return なども使えます
  fi
done
# これは無限ループとなります

```

なにかコマンドを書かなくてはならないが、実際にはなにもしたくないときもヌルコマンドは使
えます

```sh
if command-list
then
  :
else
  command
fi
```

- また、特別な使用法として、変数の設定だけを行わせることができます
- 条件によって、変数をセットします

```sh
$ : ${VAR:=abc}       # 未定義か null であれば abc という値を代入する
```

`:` コマンドを使ってデフォルト値を設定できます。
`:` ではなく `echo` を使うと変数を展開して表示してしまいます。そういう表示をせず設定
だけでいいというときに利用できます。

また、変数に値が設定されていない場合はスクリプトの処理を実行できないというときには、以
下のようにメッセージを出力し、その時点でスクリプトを終了します

```sh
: ${VAR:?"exit script because VAR is not set."}
```

`:` コマンドは本当に「何もしない」わけではなく、引数として与えた変数の設定は行うという
ことに気をつけてください


__例) null ファイルを作る | 中身を消去する__

```sh
$ : > file
# もしファイルが存在していたら中身が0になり、
# 存在していなかったら中身が0のファイルを作ります

# これは以下と同じです
$ cp /dev/null file
$ cat /dev/null file
```


### 3.2.2 ドットコマンド `.`

```sh
. file
```

- ピリオドがそのコマンドです
- 普通のコマンドとは違い、新しくプロセスを作らずに現行のシェルのプロセスを使って指定さ
れたファイルを読み込み実行します


### 3.2.3 `break` コマンド

```sh
break
```

- `for` や `while` のループから抜け出るときに使用するコマンドです
- デフォルトでは1個のループを抜けます
- ループがネストしているとき、いくつのループを抜けるか引数として指定できます

```sh
break [number]
```

### 3.2.4 `cd` コマンド

```sh
cd [directory]
```

- 引数で指定した `directory` に移動します
- 引数を指定しなかった場合には、そのユーザーのホームディレクトリに移動します


### 3.2.5 `continue` コマンド

```sh
continue
```

- ループを「次の繰り返しのステップ」に進ませます
- ループがネストしているとき、何番目のループの繰り返しに戻るか引数として指定できます

```sh
continue [number]
```


### 3.2.6 `echo` コマンド

```sh
echo parameter
```

- 引数の部分を標準出力すに表示するコマンドです


### 3.2.7 `eval` コマンド

```sh
eval [string...]
```

- 変数の置換やコマンドの置換、ワイルドカードの展開などが複雑に絡んでいるときに、1行の
コマンドでいっぺんに展開させてしまうものです
- 複数の変換処理を一度にやってしまいたいときに `eval` を使います
- あるコマンドの結果が「何かを実行させるコマンドの形式をとって」返されたとき、それをそ
のまま実行させる
- バッククートで囲む、`eval` はその結果を「実行」させます。囲んでない場合は変数を展開
させるだけです


__例)__

```sh
$ VAR1=value
$ VAR2=VAR1         # VAR2 に VAR1 の値をセットしたい
$ echo $"$VAR2"
$VAR1               # x うまく展開されない
$ echo $$VAR2
4595VAR2            # `$$`というプロセスIDが先に処理される
$ echo $'$VAR2'
$VAR2
$ echo \$$VAR2
$VAR1

# eval を使う
$ eval echo \$$VAR2
# または
$ eval echo \$"$VAR2"
```


__例)__

```sh
$ resize
COLUMNS=85;
LINES=24;
export COLUMSN LINES;
$
$ eval `resize`       #
```

__バッククオート__

バッククオートで囲むとコマンドとして実行する

```sh
$ eval `resize`         # resize コマンドはそのまま実行できる形式で結果を返す

$ eval `echo \$$VAR2`   # 変数を展開して文字列を返す
value: not found        # 展開した結果の value という文字列を、コマンドとして
                        # 実行しようとした
$
```

### 3.2.8 `exec` コマンド

```sh
exec command
```

- 新しいプロセスを作らず現行のカレントシェルのプロセスと置き換えて、引数のコマンドを実行する
- コマンドを実行したら、もう元のシェルに戻ることはありません

```sh
#!/bin/sh
exec ls -l
echo abc
```


### 3.2.9 `exit` コマンド

```sh
exit [number]
```

- シェルを終了するときに使います
- 番号を引数にすることでシェルスクリプトの終了コードを指定できます
- この終了コードが `$?` 変数に渡されます


### 3.2.10 `export` コマンド

```sh
export name
```

- `name` で指定した変数を他のコマンドやシェルからも利用できるようになります


### 3.2.11 `pwd` コマンド

- カレンディレクトリの完全パスからのツリー構造で今現在いる位置を表示します
- UNIX にはシンボリックリンクがあるため、1つの場所を指し示すのに何通りかの経路が存在
することがあります。


### 3.2.12 `read` コマンド

```sh
read variable
```

- キーボードからの入力を `variable` という変数にセットします

```sh
#!/bin/sh
echo -n "enter yes or no -->"
# または
echo "yes or no --> \c"
read ANSWER
```

__例) 複数受け取る__

```sh
#!/bin/sh
echo -n "enter some words --> "
# または
# echo "enter some words -> \c "
read ANS1 ANS2 ANS3

# 変数の数が入力より少ない場合は、最後の変数にあまりの入力がまとめられます
# 変数の数が入力より多い場合は、余った変数に null がセットされます
```


### 3.2.13 `readonly` コマンド

```sh
readonly name..
```

- `name` で指定された変数を `readonly` （書き換え不可）にします
- これを行った後では、変数に値を代入したり `unset` したりできなくなります
- このコマンドはシェルスクリプト中でほとんど使われません
- 対話的処理の中で、誤って値を変えてしまいたくない変数に対して設定するものです


### 3.2.14 `return` コマンド

```sh
return exitstatus
```

- シェルの関数から抜けるコマンドです
- `exitsstatus` に指定した番号がその関数の終了コードになります
- 番号の指定がされなかった場合には、関数が終了する直前のコマンドの実行終了こーどが返ります


### 3.2.15 `set` コマンド

```sh
set parameter
```

- シェルのオプションをオンにしたりオフにしたりします

```sh
$ sh              # シェルを起動
$ echo abc        # 普通にコマンドを打つと、普通に結果が出る
abc
$ set -v          # `-v` オプション（冗長モード）を付ける
$ echo abc        # コマンドを打つと、入力コマンドを表示後、結果が出る
echo abc
abc
$ set +v          # `-v` オプションを元に戻す
set +v            # このときはまだ `-v` が生きているからコマンドを表示
$ echo abc        # `-v` オプションがオフになり、入力コマンドは表示されない
abc
$
```

__オプションの一部__

|Option|Summary|
|:--|:--|
|-I| `^D` による `EOF` を無視する|
|-i|対話的に動作するようにする|
|-n|コマンドを読み取るが、実行はしない|
|-s|コマンドを標準入力から読む|
|-v|入力されたコマンドを標準エラーに出力する|
|-x|コマンドの実行前に、実行するコマンドを標準エラーに出力する|

`-` を伴うとフラグがオンになり、`+` を伴うとオフになる

__例)__

```sh
#!/bin/sh
echo $0 $1 $2 $3 $4
set aa bb cc
echo $0 $1 $2 $3 $4
```
これを `vvv` でファイルに保存

```sh
$ vvv 1 2 3 4 5
./vvv 1 2 3 4
./vvv aa bb cc
$
```

### 3.2.16 `shift` コマンド

```sh
shift number
```

- 位置パラメタの値を左にずらします
- `$2` を `$1` に、`$3` を　`$2` に、というように

__例)__

```sh
#!/bin/sh
echo $0 $1 $2 $3 $4 $5 $6 $7 $8 $9
shift
echo $0 $1 $2 $3 $4 $5 $6 $7 $8 $9
```

これを `ooo` でファイルに保存

```sh
$ ./ooo aa bb cc dd ee ff gg hh ii
./ooo aa bb cc dd ee ff gg hh ii
./ooo bb cc dd ee ff gg hh ii
```

- 実際に位置パラメタに値が入っていないところまでシフトさせようとするとエラーになります
- 上記のシェルスクリプトで、最後に `shift 7` と書いてみると `can't shift that many`
というエラーが発生します (mac ではエラーはでなかった)


__例) 最初に位置パラメタをクリアさせたい場合__

```sh
shift $#
```


### 3.2.17 `test` コマンド

```sh
# 以下のような2通りの書き方ができます
test expression
[ expression ]
```

- ある条件を判定し、正しいか正しくないかによって真偽を返します


__ファイルに関するテスト__

|Option|Summary|
|:--|:--|
|`-r file`|file が「読み取り可」なら `true`|
|`-w file`|file が「書き込み可」なら `true`|
|`-x file`|file が「実行可」なら `true`|
|`-f file`|file が「普通のファイル」なら `true`|
|`-d file`|file が「ディレクトリ」なら `true`|
|`-s file`|file が「0より大きいサイズ」なら `true`|


__文字列に関するテスト__

|Option|Summary|
|:--|:--|
|`-z string`|string の「長さが0」なら `true`|
|`-n string`|string の「長さが0より大」なら `true`|
|`string`|string が「 `null` でなければ」 `true`|
|`str1 = str2`|`str1` と `str2` が「同じ」なら `true`|
|`str1 != str2`|`str1` と `str2` が「同じでない」なら `true`|


__数値に関するテスト__

|Option|Summary|
|:--|:--|
|`int1 -eq int2`|`int1` と `int2` が「等しい」なら `true`|
|`int1 -ne int2`|`int1` と `int2` が「等しくない」なら `true`|
|`int1 -lt int2`|`int1` が `int2` 「より小さい（`less than`）」なら `true`|
|`int1 -le int2`|`int1` が `int2` 「以下（`less than or equal`）」なら `true`|
|`int1 -gt int2`|`int1` が `int2` 「より大きい（`greater than`）」なら `true`|
|`int1 -ge int2`|`int1` が `int2` 「以上（`greater than or equal`）」なら `true`|


__その他__

|Option|Summary|
|:--|:--|
|`!`|`NOT` （否）。「この直後の判定が `false`」なら `true`|
|`-a`|`AND` （かつ）。「この前後の判定がどちらも `true`」なら `true`|
|`-o`|`OR` （または）。「この前後の判定のどちらかが `true`」なら `true`|
|`( expr )`|グルーピング。判定の優先順位を高める|

- これがすべてではありません。
- UNIX によっては判定できないオプションもあります


__例)__

```sh
[ -r file -a -w file -q ! -x file]
# file が読み書き可能で実行不可の場合に `true`

[ -d directory -a -x directory ]
# directory がディレクトリで、移動可能なら `true`

[ $NUM1 -gt $NUM2 ]
# `$NUM1` に代入されている値が `$NUM2` の値より大きいなら `true`

[ "$STRING" != "" ]
# `$STRING` になんらかの文字が代入されていれば `true`

[ $NUM1 -lt $NUM2 -o $NUM1 -gt $NUM3 -a $NUM2 -le $NUM3 ]
# $NUM1 が $NUM2 より小さいか、あるいは
# $NUM1 が $NUM3 より大きく $NUM2 が $NUM3 以下のとき `true`

# -a の優先度が高いので、以下のような式と同等である
# ($NUM1 -lt $NUM2) または ($NUM1 -gt $num3 かつ $NUM2 -le $num3)

# -o の部分を先に判定したいなら以下のように書かなくてはいけない
# [\( $NUM1 -lt $NUM2 -o $NUM1 -gt $NUM3 \) -a $NUM2 -le $NUM3 ]
```

- それぞれの判定式やオプションの間にスペースがなくてはならないことに留意する
- この判定式を読みやすくしようとして複数行に分けることは避けてください
- 丸括弧で囲むとき、前後にスペースを置きます
- 丸括弧はシェルの特殊文字であるため、クォートしておかないと `test` コマンドで判定する
条件として扱われません

```sh
if [ ! \( -r file -a -w file \) ]
then
  echo "The file is not readble and writeble."
fi
# file が「読み書き可能である」ことを否定した判定文
# 「読めてかつ書ける」状態では「ない」ときに `true` となる
# 丸括弧を `\` でエスケープすることでシェルが解釈しないようにします
```


### 3.2.18 `trap` コマンド

```sh
trap action signal...
```

- `sgnal` にしていしたシグナルを受け取った時どういう処理ををするかを `action` に指定します
- `action` はコマンドを並べたものです
